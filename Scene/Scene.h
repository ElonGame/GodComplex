//////////////////////////////////////////////////////////////////////////
// Loads a binary scene generated by the FBXTestConverter tool
//
#pragma once

class	Scene
{
protected:	// CONSTANTS

public:		// NESTED TYPES

	class ISceneTagger;

	class	Node
	{
	public:

		enum	TYPE {
			GENERIC = 0,
			MESH,
			LIGHT,
			CAMERA,
		}					m_Type;
		Node*				m_pParent;
		int					m_ChildrenCount;
		Node**				m_ppChildren;
		NjFloat4x4			m_Local2Parent;
		NjFloat4x4			m_Local2World;

		void*				m_pTag;	// Custom user tag filled with anything the user needs to render the node

	private:
		Node( Node* _pParent, const U8*& _pData );
		~Node();

		virtual void	LoadSpecific( const U8*& _pData )	{}

		friend class Scene;
	};

	class	Light : public Node
	{
	public:

		enum	LIGHT_TYPE {
			POINT = 0,
			DIRECTIONAL,
			SPOT,
		}					m_LightType;
		NjFloat3			m_Color;
		float				m_Intensity;
		float				m_HotSpot;	// For spots only
		float				m_Falloff;	// For spots only

	private:

		Light( Node* _pParent, const U8*& _pData );
		~Light();

		virtual void	LoadSpecific( const U8*& _pData ) override;

		friend class Scene;
	};

	class	Camera : public Node
	{
	public:

		float				m_FOV;

	private:

		Camera( Node* _pParent, const U8*& _pData );
		~Camera();

		virtual void	LoadSpecific( const U8*& _pData ) override;

		friend class Scene;
	};

	class	Mesh : public Node
	{
	public:	// NESTED TYPES

		class	Primitive
		{
		public:
			U32				m_MaterialID;
			Material*		m_pMaterial;

			U32				m_FacesCount;
			U32*			m_pFaces;

			enum	VERTEX_FORMAT
			{
				P3N3G3B3T2,		// Position3, Normal3, Tangent3, BiTangent3, UV2

			}				m_VertexFormat;
			U32				m_VerticesCount;
			void*			m_pVertices;

			void*			m_pTag;	// Custom user tag filled with anything the user needs to render the node

		private:
			Primitive();
			~Primitive();

			void		Load( const U8*& _pData );

			friend class Mesh;
		};

	public:	// FIELDS

		int					m_PrimitivesCount;
		Primitive*			m_pPrimitives;

	private:

		Mesh( Node* _pParent, const U8*& _pData, const ISceneTagger& _SceneTagger );
		~Mesh();

		virtual void	LoadSpecific( const U8*& _pData ) override;

		friend class Scene;
	};

	class	Material
	{
	public:	// NESTED TYPES


	public:	// FIELDS

		U32					m_ID;
//		NjFloat3			m_Ambient;
		NjFloat3			m_DiffuseAlbedo;
		U32					m_TexIDDiffuseAlbedo;
		NjFloat3			m_SpecularAlbedo;
		U32					m_TexIDSpecularAlbedo;
		NjFloat3			m_SpecularExponent;

		void*				m_pTag;	// Custom user tag filled with anything the user needs to render the node

	private:

		Material( const U8*& _pData );
//		~Material();

		friend class Scene;
	};


	// Interface passed to the scene loading method to tag abstract scene objects with actual rendering data
	class	ISceneTagger
	{
	public:
		// Tags a material with a special user pointer
		virtual void*	TagMaterial( const Scene::Material& _Material ) const abstract;

		// Tags a node with a special user pointer
		virtual void*	TagNode( const Scene::Node& _Node ) const abstract;

		// Tags a primitive with a special user pointer
		virtual void*	TagPrimitive( const Scene::Mesh& _Mesh, const Scene::Mesh::Primitive& _Primitive ) const abstract;
	};


private:	// FIELDS

//	int				m_NodesCount;
	Node*			m_pROOT;

	int				m_MaterialsCount;
	Material**		m_ppMaterials;

public:		// METHODS

	Scene();
	~Scene();

	void	Load( U16 _SceneResourceID, const ISceneTagger& _SceneTagger );
	void	Render( );

private:

	// Helpers
	static Node*	CreateNode( Node* _pParent, const U8*& _pData, const ISceneTagger& _SceneTagger );
	static U16		ReadU16( const U8*& _pData );
	static U32		ReadU32( const U8*& _pData );
	static float	ReadF32( const U8*& _pData );
	static void		ReadEndMaterialMarker( const U8*& _pData );
	static void		ReadEndNodeMarker( const U8*& _pData );
};
