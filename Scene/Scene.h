//////////////////////////////////////////////////////////////////////////
// Loads a binary GCX scene generated by the FBXTestConverter tool
//
#pragma once

class	Scene
{
protected:	// CONSTANTS

public:		// NESTED TYPES

	class ISceneTagger;
	class Material;

	class	Node
	{
	public:

		Scene&				m_Owner;
		enum	TYPE {
			GENERIC = 0,
			MESH,
			LIGHT,
			CAMERA,

			// Special nodes
			PROBE,
		}					m_Type;
		Node*				m_pParent;
		int					m_ChildrenCount;
		Node**				m_ppChildren;
		NjFloat4x4			m_Local2Parent;
		NjFloat4x4			m_Local2World;

		void*				m_pTag;	// Custom user tag filled with anything the user needs to render the node

	private:
		Node( Scene& _Owner, Node* _pParent );
		~Node();

		void			Init( const U8*& _pData, const ISceneTagger& _SceneTagger );
		void			Exit( const ISceneTagger& _SceneTagClearer );

		// Override this in your inherited classes to init/exit specific details of the node
		virtual void	InitSpecific( const U8*& _pData, const ISceneTagger& _SceneTagger )	{}
		virtual void	ExitSpecific( const ISceneTagger& _SceneTagClearer )				{}

		friend class Scene;
	};

	class	Light : public Node
	{
	public:

		enum	LIGHT_TYPE {
			POINT = 0,
			DIRECTIONAL,
			SPOT,
		}					m_LightType;
		NjFloat3			m_Color;
		float				m_Intensity;
		float				m_HotSpot;	// For spots only
		float				m_Falloff;	// For spots only

	private:

		Light( Scene& _Owner, Node* _pParent );
		~Light();

		virtual void	InitSpecific( const U8*& _pData, const ISceneTagger& _SceneTagger ) override;

		friend class Scene;
	};

	class	Camera : public Node
	{
	public:

		float				m_FOV;

	private:

		Camera( Scene& _Owner, Node* _pParent );
		~Camera();

		virtual void	InitSpecific( const U8*& _pData, const ISceneTagger& _SceneTagger ) override;

		friend class Scene;
	};

	class	Mesh : public Node
	{
	public:	// NESTED TYPES

		class	Primitive
		{
		public:
			::Scene::Material*	m_pMaterial;

			U32				m_FacesCount;
			U32*			m_pFaces;

			enum	VERTEX_FORMAT
			{
				P3N3G3B3T2,		// Position3, Normal3, Tangent3, BiTangent3, UV2

			}				m_VertexFormat;
			U32				m_VerticesCount;
			void*			m_pVertices;

			void*			m_pTag;	// Custom user tag filled with anything the user needs to render the node

		private:
			Primitive();
			~Primitive();

			void		Init( Scene& _Owner, const U8*& _pData );

			friend class Mesh;
		};

	public:	// FIELDS

		int					m_PrimitivesCount;
		Primitive*			m_pPrimitives;

	private:

		Mesh( Scene& _Owner, Node* _pParent );
		~Mesh();

		virtual void	InitSpecific( const U8*& _pData, const ISceneTagger& _SceneTagger ) override;
		virtual void	ExitSpecific( const ISceneTagger& _SceneTagClearer ) override;

		friend class Scene;
	};

	class	Probe : public Node
	{
	private:

		Probe( Scene& _Owner, Node* _pParent );
		~Probe();

		friend class Scene;
	};

	class	Material
	{
	public:	// NESTED TYPES

		class	Texture
		{
		public:
			U32				m_ID;
			void*			m_pTag;

			Texture() : m_ID(-1), m_pTag(NULL) {}
		};

	public:	// FIELDS

		U32					m_ID;
		NjFloat3			m_Ambient;
		NjFloat3			m_DiffuseAlbedo;
		Texture				m_TexDiffuseAlbedo;
		NjFloat3			m_SpecularAlbedo;
		Texture				m_TexSpecularAlbedo;
		NjFloat3			m_SpecularExponent;

		void*				m_pTag;	// Custom user tag filled with anything the user needs to render the node

	private:

		Material();

		void	Init( const U8*& _pData, const ISceneTagger& _SceneTagger );
		void	Exit( const ISceneTagger& _SceneTagClearer );

		friend class Scene;
	};


	// Interface passed to the scene loading method to tag abstract scene objects with actual rendering data (also called on scene destruction to clear any leftovers)
	class	ISceneTagger
	{
	public:
		// Tags a material with a special user pointer
		virtual void*	TagMaterial( const Scene::Material& _Material ) const abstract;

		// Tags a texture with a special user pointer
		virtual void*	TagTexture( const Scene::Material::Texture& _Texture ) const abstract;

		// Tags a node with a special user pointer
		virtual void*	TagNode( const Scene::Node& _Node ) const abstract;

		// Tags a primitive with a special user pointer
		virtual void*	TagPrimitive( const Scene::Mesh& _Mesh, const Scene::Mesh::Primitive& _Primitive ) const abstract;
	};

	// Interface passed to the scene loading method to tag abstract scene objects with actual rendering data
	class	ISceneRenderer
	{
	public:
		// Renders a mesh
		//	_Mesh, the mesh to render
		//	_pMaterialOverride, an optional material used to override the mesh's default material
		virtual void	RenderMesh( const Scene::Mesh& _Mesh, ::Material* _pMaterialOverride ) const abstract;
	};


private:	// FIELDS

	Node*				m_pROOT;

	int					m_MaterialsCount;
	Material**			m_ppMaterials;

	const ISceneTagger*	m_pSceneTagger;


public:		// METHODS

	Scene();
	~Scene();	// WARNING: Call "ClearTags" to dispose of your tags prior destruction!


	void			Load( U16 _SceneResourceID, const ISceneTagger& _SceneTagger );
	void			Render( const ISceneRenderer& _SceneRenderer ) const;
	void			ClearTags( const ISceneTagger& _SceneTagClearer );

	// Iterates over all the nodes of specific type
	//	_pPrevious, should be NULL for the first call to trigger a new search
	Node*			ForEach( Node::TYPE _Type, Node* _pPrevious, int _StartAtChild=0 );


private:

	void			Render( const Node* _pNode, const ISceneRenderer& _SceneRenderer ) const;

	// Helpers
	Node*			CreateNode( Node* _pParent, const U8*& _pData, const ISceneTagger& _SceneTagger );
	static U32		ReadU16( const U8*& _pData, bool _IsID=false );
	static U32		ReadU32( const U8*& _pData );
	static float	ReadF32( const U8*& _pData );
	static void		ReadEndMaterialMarker( const U8*& _pData );
	static void		ReadEndNodeMarker( const U8*& _pData );
};
