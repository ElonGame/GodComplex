//////////////////////////////////////////////////////////////////////////
// This is my brand new awesome tool used to create Standardized Albedo Diffuse textures!
//
// I equipped my Canon DSLR with a circular polarization filter and an annular flash also rigged with a custom-made
//	polarization filter that is obviously rotated 90+ from the one on the lens. This way I'm getting rid of specular
//	reflections as described by http://filmicgames.com/archives/233
//
// I pushed the thing further than John though and bought some expensive reflectance standards on eBay from SphereLabs:
//	http://www.labsphere.com/products/reflectance-standards-and-targets/spectralon-reflectance-standards/default.aspx
//
// This way, I can properly calibrate my camera by measuring and compensating my camera's raw sensor data
//
// Once I have built a proper database of sensor data for various ISO, Shutter speed and aperture settings I can start
//	grabbing some actual materials:
//	_ I place the sample in front of the lens with the 99% white diffuse reflectance standard
//	_ I pick the standard as my white reference
//	_ Then I remove the standard and take a shot again
//	_ Finally, I just need to crop and capture the result that gets properly calibrated
//	_ Optionnaly, I can take some custom color swatches at different locations in the captured image
//
//
// Technically, I implemented many things like a very sound Bitmap2 class that handles RAW files as well as many other
//	standard formats (although only RAW files should be used with this software!). It extracts color profiles from the
//	original image and various other settings if they're available and the internal picture format is stored into the
//	device-independent CIE XYZ color space (conversion to RGB can only occur through the use of a color profile!).
//
// The calibration database collects all the calibration informations stored in a directory (as XML files) and generates
//	a "3D grid" of calibration informations. Each dimension of the grid encodes ISO speed, Shutter speed and Aperture
//	settings so if you feed it any picture within the database's range you get an interpolated calibration that allows
//	you to retrieve the proper reflectance of a pixel given its luminance Y: you get returned a value between 2% and 99%
//	diffuse reflectance.
//
// Finally, the software is capable of reflectance correcting an entire image and store it as a plain 16-bits PNG sRGB
//	image so it's directly useable by artists in their textures, providing they don't change the color profile and don't
//	apply any color correction to the original texture!
//
// The color correction bit is 3-fold:
//	1) As mentioned earlier, a white reference picking from the image, just to adjust the white reflectance level of the particular shot
//		(because, although the calibration has been done, lighting may change a little from the images used as calibration)
//
//	2) A quite important "white reference image" which is simply a capture of a white sheet of paper.
//		I use it to compensate the fluctuations of lighting depending on the position in the image so I can correct lighting in
//		any subsequent image
//
//	3) An optional but recommended color correction applied in sRGB device-dependent HSV space called "hue twisting"
//		(cf. http://dcptool.sourceforge.net/Hue%20Twists.html)
//		The hue twist file comes from a DCP (Digital Camera Profile) image that was generated from an image of the
//		X-Rite color checker passport (http://xritephoto.com/ph_product_overview.aspx?id=1257).
//		I use the DCPTool software in the Packages directory to decompile the DCP file generated by X-Rite into a
//		simple XML file.
//
//////////////////////////////////////////////////////////////////////////
//
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using Microsoft.Win32;

namespace StandardizedDiffuseAlbedoMaps
{
	public partial class Form1 : Form
	{
		#region CONSTANTS

		private const string	APP_TITLE = "Standardized Diffuse Albedo Maps Creator";
		private const float		BLACK_VALUES_TOLERANCE = 0.05f;				// We can tolerate up to 5% black values for a probe to be valid
		private const float		SATURATED_VALUES_TOLERANCE = 0.05f;			// We can tolerate up to 5% saturated values for a probe to be valid
		private const int		DEFAULT_WHITE_REFERENCE_IMAGE_SIZE = 256;	// Maximum size of the generated white reference files will be 256 (we don't need much precision)

		#endregion

		#region NESTED TYPES

		private class	Swatch
		{
			public Form1		m_Owner = null;
			public Panel		m_Panel = null;

			public float3		m_xyY;		// Last picked xyY color
			public float3		m_RGB;		// Last picked xyY converted into RGB (sRGB) for screen display (also assigned to m_Panel.BackColor)

			public virtual void	UpdateSwatchColor()
			{
				m_RGB = (float3) m_Owner.m_sRGBProfile.XYZ2RGB( new float4( Bitmap2.ColorProfile.xyY2XYZ( m_xyY ), 1.0f ) );

				Color	C = Color.FromArgb( Math.Max( 0, Math.Min( 255, (int) (m_RGB.x * 255.0f) ) ),
											Math.Max( 0, Math.Min( 255, (int) (m_RGB.y * 255.0f) ) ),
											Math.Max( 0, Math.Min( 255, (int) (m_RGB.z * 255.0f) ) ) );
				m_Panel.BackColor = C;
			}
		}
		private class	CustomSwatch : Swatch
		{
			public CheckBox		m_CheckBox = null;

			public float2		m_LocationTopLeft = new float2( -1, -1 );		// Last picked location
			public float2		m_LocationBottomRight = new float2( -1, -1 );	// Last picked location

			public override void UpdateSwatchColor()
			{
				if ( !m_CheckBox.Checked || m_Owner.m_Texture == null )
				{
					m_CheckBox.Checked = false;
					m_xyY = m_RGB = new float3( 0, 0, 0 );
					m_Panel.BackColor = Color.DimGray;
					return;
				}

				// Re-capture
				m_xyY = m_Owner.m_Texture.ComputeAverageSwatchColor( m_LocationTopLeft, m_LocationBottomRight );
				base.UpdateSwatchColor();
			}
		}

		#endregion

		#region FIELDS

		private RegistryKey					m_AppKey;
		private string						m_ApplicationPath;

		private Bitmap2.ColorProfile		m_sRGBProfile = new Bitmap2.ColorProfile( Bitmap2.ColorProfile.STANDARD_PROFILE.sRGB );	// For conversion to the screen

		// The currently loaded image
		private System.IO.FileInfo			m_ImageFileName = null;
		private Bitmap2						m_BitmapXYZ = null;

		// Generated calibrated texture
		private CalibratedTexture			m_Texture = null;

		// Calibration database
		private CameraCalibrationDatabase	m_CalibrationDatabase = new CameraCalibrationDatabase();
		private CameraCalibration			m_Calibration = new CameraCalibration();	// Current calibration

		// Custom swatches
		private Swatch						m_SwatchMin;
		private Swatch						m_SwatchMax;
		private Swatch						m_SwatchAvg;
		private CustomSwatch[]				m_CustomSwatches = new CustomSwatch[9];

		#endregion

		#region METHODS

		public Form1()
		{
 			m_AppKey = Registry.CurrentUser.CreateSubKey( @"Software\GodComplex\StandardizedDiffuseAlbedoMaps" );
			m_ApplicationPath = System.IO.Path.GetDirectoryName( Application.ExecutablePath );

			InitializeComponent();

			// Initialize color swatches
			m_SwatchMin = new Swatch() { m_Owner = this, m_Panel = panelSwatchMin };
			m_SwatchMax = new Swatch() { m_Owner = this, m_Panel = panelSwatchMax };
			m_SwatchAvg = new Swatch() { m_Owner = this, m_Panel = panelSwatchAverage };
			m_CustomSwatches[0] = new CustomSwatch() { m_Owner = this, m_CheckBox = checkBoxCustomSwatch0, m_Panel = panelCustomSwatch0 };
			m_CustomSwatches[1] = new CustomSwatch() { m_Owner = this, m_CheckBox = checkBoxCustomSwatch1, m_Panel = panelCustomSwatch1 };
			m_CustomSwatches[2] = new CustomSwatch() { m_Owner = this, m_CheckBox = checkBoxCustomSwatch2, m_Panel = panelCustomSwatch2 };
			m_CustomSwatches[3] = new CustomSwatch() { m_Owner = this, m_CheckBox = checkBoxCustomSwatch3, m_Panel = panelCustomSwatch3 };
			m_CustomSwatches[4] = new CustomSwatch() { m_Owner = this, m_CheckBox = checkBoxCustomSwatch4, m_Panel = panelCustomSwatch4 };
			m_CustomSwatches[5] = new CustomSwatch() { m_Owner = this, m_CheckBox = checkBoxCustomSwatch5, m_Panel = panelCustomSwatch5 };
			m_CustomSwatches[6] = new CustomSwatch() { m_Owner = this, m_CheckBox = checkBoxCustomSwatch6, m_Panel = panelCustomSwatch6 };
			m_CustomSwatches[7] = new CustomSwatch() { m_Owner = this, m_CheckBox = checkBoxCustomSwatch7, m_Panel = panelCustomSwatch7 };
			m_CustomSwatches[8] = new CustomSwatch() { m_Owner = this, m_CheckBox = checkBoxCustomSwatch8, m_Panel = panelCustomSwatch8 };
		}

		protected override void OnLoad( EventArgs e )
		{
			base.OnLoad( e );

			ReloadDatabase();
			UpdateUIFromCalibration();

			// Reload old white reflectance reference if there's one...
			bool	reload;
			if ( bool.TryParse( GetRegKey( "ReloadWhiteReflectanceOnStartup", "false" ), out reload ) && reload )
			{
				string	WhiteRefFileNameStr = GetRegKey( "LastWhiteReflectanceFilename", "" );
				if ( System.IO.File.Exists( WhiteRefFileNameStr ) )
				{
					System.IO.FileInfo	WhiteRefFileName = new System.IO.FileInfo( WhiteRefFileNameStr );
					LoadWhiteReflectanceFile( WhiteRefFileName, false );
				}
			}

			// Reload old white reference image if there's one...
			if ( bool.TryParse( GetRegKey( "ReloadWhiteReferenceImageOnStartup", "false" ), out reload ) && reload )
			{
				string	WhiteRefFileNameStr = GetRegKey( "LastWhiteReferenceImageFilename", "" );
				if ( System.IO.File.Exists( WhiteRefFileNameStr ) )
				{
					System.IO.FileInfo	WhiteRefFileName = new System.IO.FileInfo( WhiteRefFileNameStr );
					LoadWhiteReferenceImage( WhiteRefFileName, false );
				}
			}
		}

		#region Helpers

		private string	GetRegKey( string _Key, string _Default )
		{
			string	Result = m_AppKey.GetValue( _Key ) as string;
			return Result != null ? Result : _Default;
		}
		private void	SetRegKey( string _Key, string _Value )
		{
			m_AppKey.SetValue( _Key, _Value );
		}

		private float	GetRegKeyFloat( string _Key, float _Default )
		{
			string	Value = GetRegKey( _Key, _Default.ToString() );
			float	Result;
			float.TryParse( Value, out Result );
			return Result;
		}

		private int		GetRegKeyInt( string _Key, float _Default )
		{
			string	Value = GetRegKey( _Key, _Default.ToString() );
			int		Result;
			int.TryParse( Value, out Result );
			return Result;
		}

		private DialogResult	MessageBox( string _Text )
		{
			return MessageBox( _Text, MessageBoxButtons.OK );
		}
		private DialogResult	MessageBox( string _Text, Exception _e )
		{
			return MessageBox( _Text + _e.Message, MessageBoxButtons.OK, MessageBoxIcon.Error );
		}
		private DialogResult	MessageBox( string _Text, MessageBoxButtons _Buttons )
		{
			return MessageBox( _Text, _Buttons, MessageBoxIcon.Information );
		}
		private DialogResult	MessageBox( string _Text, MessageBoxIcon _Icon )
		{
			return MessageBox( _Text, MessageBoxButtons.OK, _Icon );
		}
		private DialogResult	MessageBox( string _Text, MessageBoxButtons _Buttons, MessageBoxIcon _Icon )
		{
			return System.Windows.Forms.MessageBox.Show( this, _Text, "Texture Reflectances Generator", _Buttons, _Icon );
		}

		#endregion

		/// <summary>
		/// Rebuilds the database by reloading all the files present in the provided database directory
		/// </summary>
		private void	ReloadDatabase()
		{
			try
			{
				m_CalibrationDatabase.DatabasePath = new System.IO.DirectoryInfo( GetRegKey( "LastCalibrationDatabasePath", System.IO.Path.GetDirectoryName( m_ApplicationPath ) ) );

				if ( !m_CalibrationDatabase.IsValid )
					MessageBox( "The database is not valid and can't be used to calibrate images!\r\n\r\nGo to the camera calibration tab and either select a new database location or create new camera calibration data.", MessageBoxButtons.OK, MessageBoxIcon.Warning );
				else if ( m_CalibrationDatabase.HasErrors )
					MessageBox( "There were some errors during database construction:\r\n\r\n" + m_CalibrationDatabase.ErrorLog, MessageBoxButtons.OK, MessageBoxIcon.Error );
			}
			catch ( Exception _e )
			{
				MessageBox( "Failed to parse the calibration database:\r\n\r\n", _e );
			}
		}

		/// <summary>
		/// Prepares the database for calibration with current image shot infos
		/// </summary>
		/// <returns>False if the database failed to prepare</returns>
		private bool	PrepareDatabase()
		{
			return PrepareDatabase( true );
		}
		private bool	PrepareDatabase( bool _AlertIfFailed )
		{
			try
			{
				m_CalibrationDatabase.PrepareCalibrationFor( floatTrackbarControlISOSpeed.Value, floatTrackbarControlShutterSpeed.Value, floatTrackbarControlAperture.Value );
			}
			catch ( Exception _e )
			{
				if ( _AlertIfFailed )
					MessageBox( "Failed to prepare the calibration database for calibrating the current image:\r\n\r\n", _e );
				return false;
			}

			return true;
		}

		/// <summary>
		/// Loads the white reflectance reference from a file
		/// </summary>
		/// <param name="_WhiteReflectanceFileName"></param>
		/// <param name="_AlertIfFailed"></param>
		private void	LoadWhiteReflectanceFile( System.IO.FileInfo _FileName, bool _AlertIfFailed )
		{
			try
			{
				// Load
				System.Xml.XmlDocument	Doc = new System.Xml.XmlDocument();
				Doc.Load( _FileName.FullName );

				System.Xml.XmlElement	Root = Doc["WhiteReflectance"];
				if ( Root == null )
					throw new Exception( "Couldn't find expected root element \"WhiteReflectance\"! Is this a white ref file?" );

				float	WhiteRef = 1.0f;
				if ( !float.TryParse( Root.GetAttribute( "Value" ), out WhiteRef ) )
					throw new Exception( "Failed to parse white reference value!" );

				m_CalibrationDatabase.WhiteReflectanceReference = WhiteRef;

				UpdateWhiteReflectanceUI();
			}
			catch ( Exception _e )
			{
				if ( _AlertIfFailed )
					MessageBox( "An error occurred while loading white reflectance file \"" + _FileName.FullName + "\":\r\n\r\n", _e );
			}
		}

		/// <summary>
		/// Loads the white reference image file
		/// </summary>
		/// <param name="_FileName"></param>
		/// <param name="_AlertIfFailed"></param>
		private void	LoadWhiteReferenceImage( System.IO.FileInfo _FileName, bool _AlertIfFailed )
		{
			buttonSaveWhiteRefImage.Enabled = false;
			buttonResetWhiteRefImage.Enabled = false;
			try
			{
				Bitmap2	RefImg = new Bitmap2( _FileName );
				m_CalibrationDatabase.WhiteReferenceImage = RefImg;

				UpdateWhiteReferenceImageUI();
			}
			catch ( Exception _e )
			{
				if ( _AlertIfFailed )
					MessageBox( "An error occurred while loading the white reference image \"" + _FileName.FullName + "\":\r\n\r\n", _e );
			}
		}

		/// <summary>
		/// Rebuilds and assigns the bitmap for the output panel from the loaded image
		/// </summary>
		private void RebuildImage()
		{
			if ( m_BitmapXYZ == null )
				return;

			bool		sRGB = checkBoxsRGB.Checked;

			float4[,]	Image = new float4[m_BitmapXYZ.Width,m_BitmapXYZ.Height];

			if ( checkBoxLuminance.Checked )
			{	// Convert into luminances only
				for ( int Y = 0; Y < m_BitmapXYZ.Height; Y++ )
					for ( int X = 0; X < m_BitmapXYZ.Width; X++ )
					{
						float L = m_BitmapXYZ.ContentXYZ[X, Y].y;
						if ( sRGB )
							L = Bitmap2.ColorProfile.Linear2sRGB( L );

						Image[X, Y].x = L;
						Image[X, Y].y = L;
						Image[X, Y].z = L;
					}
			}
			else
			{	// RGB

				// Build conversion profile
				Bitmap2.ColorProfile	Profile = new Bitmap2.ColorProfile(
					Bitmap2.ColorProfile.Chromaticities.sRGB,													// Always use standard sRGB illuminant
					sRGB ? Bitmap2.ColorProfile.GAMMA_CURVE.sRGB : Bitmap2.ColorProfile.GAMMA_CURVE.STANDARD,	// Either use sRGB linear toe or a standard gamma
					sRGB ? Bitmap2.ColorProfile.GAMMA_EXPONENT_sRGB : 1.0f );									// Either use sRGB gamma or linear gamma

				// Convert
				Profile.XYZ2RGB( m_BitmapXYZ.ContentXYZ, Image );
			}

			outputPanel.Image = Image;
		}

		#endregion

		#region EVENT HANDLERS

		private void buttonLoadImage_Click( object sender, EventArgs e )
		{
 			string	OldFileName = GetRegKey( "LastImageFilename", m_ApplicationPath );
			openFileDialogSourceImage.InitialDirectory = System.IO.Path.GetDirectoryName( OldFileName );
			openFileDialogSourceImage.FileName = System.IO.Path.GetFileName( OldFileName );

			if ( openFileDialogSourceImage.ShowDialog( this ) != DialogResult.OK )
 				return;

			SetRegKey( "LastImageFilename", openFileDialogSourceImage.FileName );

			try
			{
				// Load
				System.IO.FileInfo	ImageFileName = new System.IO.FileInfo( openFileDialogSourceImage.FileName );
				Bitmap2	NewBitmap = new Bitmap2( ImageFileName );

				// Safely assign once loaded
				m_ImageFileName = ImageFileName;
				m_BitmapXYZ = NewBitmap;

				this.Text = APP_TITLE + " (" + ImageFileName.Name + ")";

				// Setup camera shot info if it exists
				if ( m_BitmapXYZ.HasValidShotInfo )
				{
					groupBoxCameraShotInfos.Enabled = false;
					floatTrackbarControlISOSpeed.Value = m_BitmapXYZ.ISOSpeed;			floatTrackbarControlISOSpeed.SimulateValueChange();	// So we get notified even if value is the same as default slider value
					floatTrackbarControlShutterSpeed.Value = m_BitmapXYZ.ShutterSpeed;	floatTrackbarControlShutterSpeed.SimulateValueChange();	// So we get notified even if value is the same as default slider value
					floatTrackbarControlAperture.Value = m_BitmapXYZ.Aperture;			floatTrackbarControlAperture.SimulateValueChange();	// So we get notified even if value is the same as default slider value
					floatTrackbarControlFocalLength.Value = m_BitmapXYZ.FocalLength;	floatTrackbarControlFocalLength.SimulateValueChange();	// So we get notified even if value is the same as default slider value
				}
				else
					groupBoxCameraShotInfos.Enabled = true;

				// Clear calibrated texture & UI
				if ( m_Texture != null )
					m_Texture.Dispose();
				m_Texture = null;
				resultTexturePanel.CalibratedTexture = null;
				buttonSaveCalibratedImage.Enabled = false;

				foreach ( CustomSwatch S in m_CustomSwatches )
				{
					S.m_CheckBox.Checked = false;
					S.m_Panel.BackColor = Color.DimGray;
				}

				PrepareDatabase( false );			// Prepare database with new camera shot infos
				UpdateWhiteReflectanceUI();		// If the shot infos are different from the ones from which the white reflectance was picked then the values got reset so update UI
				RebuildImage();						// Finally, rebuild the image and show it in the output panel
				outputPanel.ResetCropRectangle();	// Previous crop rectangle is not valid anymore
			}
			catch ( Exception _e )
			{
				MessageBox( "An error occurred while loading the image:\r\n\r\n", _e );
			}
		}

		private void outputPanel_MouseMove( object sender, MouseEventArgs e )
		{
			if ( m_BitmapXYZ == null )
				return;

			RectangleF	R = outputPanel.ImageClientRectangle;

			float	X = (e.X - R.Left) / R.Width;
			float	Y = (e.Y - R.Top) / R.Height;
			if ( X < 0.0f || X > 1.0f || Y < 0.0f || Y > 1.0f )
			{
				labelLuminance.Text = "";
				return;
			}

			X *= m_BitmapXYZ.Width;
			Y *= m_BitmapXYZ.Height;

			float	Lum = m_BitmapXYZ.BilinearSample( X, Y ).y;
			float	Lum_sRGB = Bitmap2.ColorProfile.Linear2sRGB( Lum );

			labelLuminance.Text = "sRGB=" + Lum_sRGB.ToString( "G4" ) + " (" + (int) (Lum_sRGB*255) + ") - Y=" + Lum.ToString( "G4" );
		}

		private void checkBoxsRGB_CheckedChanged( object sender, EventArgs e )
		{
			RebuildImage();
		}

		private void checkBoxLuminance_CheckedChanged( object sender, EventArgs e )
		{
			RebuildImage();
		}

		#region Calibration

		/// <summary>
		/// Integrates the luminance of the pixels in a given circle selected by the user
		/// </summary>
		/// <param name="_X"></param>
		/// <param name="_Y"></param>
		/// <param name="_Radius"></param>
		/// <param name="_PercentOfBlackValues"></param>
		/// <param name="_HasSaturatedValues">Returns the percentage of encountered saturated values. 0 is okay, more means the probe shouldn't be used</param>
		/// <returns></returns>
		private float	IntegrateLuminance( float _X, float _Y, float _Radius, out float _PercentOfBlackValues, out float _PercentOfSaturatedValues )
		{
			float	Radius = _Radius * m_BitmapXYZ.Width;
			float	CenterX = _X * m_BitmapXYZ.Width;
			float	CenterY = _Y * m_BitmapXYZ.Height;
			float	SqRadius = Radius*Radius;

			int	X0 = Math.Max( 0, Math.Min( m_BitmapXYZ.Width-1, (int) Math.Floor( CenterX - Radius ) ) );
			int	X1 = Math.Max( 0, Math.Min( m_BitmapXYZ.Width-1, (int) Math.Ceiling( CenterX + Radius ) ) );
			int	Y0 = Math.Max( 0, Math.Min( m_BitmapXYZ.Height-1, (int) Math.Floor( CenterY - Radius ) ) );
			int	Y1 = Math.Max( 0, Math.Min( m_BitmapXYZ.Height-1, (int) Math.Ceiling( CenterY + Radius ) ) );

			const float	SMOOTHSTEP_MAX_RADIUS = 0.2f;	// We reach max weight 1 at 20% of the border of the circle

			int		TotalBlackValuesCount = 0;
			int		TotalSaturatedValuesCount = 0;
			int		TotalValuesCount = 0;
			float	SumLuminance = 0.0f;
			float	SumWeights = 0.0f;
			for ( int Y=Y0; Y < Y1; Y++ )
				for ( int X=X0; X < X1; X++ )
				{
					float	SqR = (X-CenterX)*(X-CenterX) + (Y-CenterY)*(Y-CenterY);
					if ( SqR > SqRadius )
						continue;

					float	r = (float) Math.Sqrt( SqR ) / Radius;	// Nomalized radius
//					float	Weight = Math.Min( 1.0f, floatTrackbarControl1.Value * (float) Math.Exp( -floatTrackbarControl2.Value * r ) );

					float	x = Math.Max( 0.0f, Math.Min( 1.0f, (1.0f - r) / SMOOTHSTEP_MAX_RADIUS ) );
					float	Weight = x*x*(3.0f - 2.0f*x);

//DEBUG					m_BitmapXYZ.ContentXYZ[X,Y].y = Weight;
					float	Luminance = m_BitmapXYZ.ContentXYZ[X,Y].y;
					if ( Luminance < 0.001f )
						TotalBlackValuesCount++;		// Warning!
					if ( Luminance > 0.999f )
						TotalSaturatedValuesCount++;	// Warning!
					TotalValuesCount++;

					SumLuminance += Weight * Luminance;
					SumWeights += Weight;
				}

//DEBUG			RebuildImage();

			_PercentOfBlackValues = (float) TotalBlackValuesCount / TotalValuesCount;
			_PercentOfSaturatedValues = (float) TotalSaturatedValuesCount / TotalValuesCount;

			SumLuminance /= SumWeights;
			return SumLuminance;
		}

		/// <summary>
		/// Integrates luminance for the provided probe by sampling luminances in the provided disc
		/// </summary>
		/// <param name="_Probe"></param>
		/// <param name="_Center"></param>
		/// <param name="_Radius"></param>
		private void	IntegrateLuminance( CameraCalibration.Probe _Probe, float2 _Center, float _Radius )
		{
			float	BlackValues, SaturatedValues;
			float	MeasuredLuminance = IntegrateLuminance( _Center.x, _Center.y, _Radius, out BlackValues, out SaturatedValues );

			bool	DisableProbe = false;
			if ( BlackValues > BLACK_VALUES_TOLERANCE &&
				MessageBox( "This probe has more than 5% luminance values that are too dark, it's advised you don't use it to calibrate the camera as its values will not be useful.\r\n" +
							"\r\nDo you wish to disable this probe?",
							MessageBoxButtons.YesNo, MessageBoxIcon.Warning ) == DialogResult.Yes )
			{
				DisableProbe = true;
			}
			else if ( SaturatedValues > SATURATED_VALUES_TOLERANCE &&
				MessageBox( "This probe has more than 5% luminance values that are saturated, it's advised you don't use it to calibrate the camera as its values will not be useful.\r\n" +
							"\r\nDo you wish to disable this probe?",
							MessageBoxButtons.YesNo, MessageBoxIcon.Warning ) == DialogResult.Yes )
			{
				DisableProbe = true;
			}

			if ( DisableProbe )
			{	// Disable probe
				_Probe.m_IsAvailable = false;
				_Probe.m_LuminanceMeasured = 0.0f;
				UpdateUIFromCalibration();
				return;
			}

			_Probe.m_LuminanceMeasured = MeasuredLuminance;

			// We now have valid measurement disc infos
			_Probe.m_MeasurementDiscIsAvailable = true;
			_Probe.m_MeasurementCenterX = _Center.x;
			_Probe.m_MeasurementCenterY = _Center.y;
			_Probe.m_MeasurementRadius = _Radius;

			CommitImageToCurrentCalibration();	// We now used the current image as reference for this calibration so commit its data
		}

		private void StartCalibrationPicking( CameraCalibration.Probe _Probe )
		{
			if ( m_BitmapXYZ == null )
			{	// No image loaded you moron!
				MessageBox( "Can't start calibration as no image is currently loaded!", MessageBoxButtons.OK, MessageBoxIcon.Exclamation );
				return;
			}

			outputPanel.StartCalibrationTargetPicking( ( float2 _Center, float _Radius ) => {
				IntegrateLuminance( _Probe, _Center, _Radius );
			} );
		}

		/// <summary>
		/// Commit image data to camera calibration
		/// Must be called as soon as the current image is used to feed data to the camera calibration
		/// </summary>
		private void CommitImageToCurrentCalibration()
		{
			m_Calibration.m_ReferenceImageName = m_ImageFileName.FullName;
			m_Calibration.m_ReferenceImageWidth = m_BitmapXYZ.Width;
			m_Calibration.m_ReferenceImageHeight = m_BitmapXYZ.Height;

			m_Calibration.m_CameraShotInfos.m_ISOSpeed = floatTrackbarControlISOSpeed.Value;
			m_Calibration.m_CameraShotInfos.m_ShutterSpeed = floatTrackbarControlShutterSpeed.Value;
			m_Calibration.m_CameraShotInfos.m_Aperture = floatTrackbarControlAperture.Value;
			m_Calibration.m_CameraShotInfos.m_FocalLength = floatTrackbarControlFocalLength.Value;

			m_Calibration.CreateThumbnail( m_BitmapXYZ );

			UpdateUIFromCalibration();
		}

		private void UpdateUIFromCalibration()
		{
			m_Calibration.UpdateAllLuminances();

			string	Format = "G4";

			labelCalbrationImageName.Text = m_Calibration.m_ReferenceImageName != null ? System.IO.Path.GetFileName( m_Calibration.m_ReferenceImageName ) : "<NO IMAGE>";

			checkBoxCalibrate02.Checked = m_Calibration.m_Reflectance02.m_IsAvailable;
			buttonCalibrate02.Enabled = m_Calibration.m_Reflectance02.m_IsAvailable;
			labelProbeNormalized02.Enabled = m_Calibration.m_Reflectance02.m_IsAvailable;
			labelProbeValue02.Text = m_Calibration.m_Reflectance02.m_IsAvailable ? m_Calibration.m_Reflectance02.m_LuminanceMeasured.ToString( Format ) : "";
			labelProbeNormalized02.Text = m_Calibration.m_Reflectance02.m_IsAvailable ? m_Calibration.m_Reflectance02.m_LuminanceNormalized.ToString( Format ) : "";
			labelProbeRelative02.Text = m_Calibration.m_Reflectance02.m_IsAvailable ? m_Calibration.m_Reflectance02.m_LuminanceRelative.ToString( Format ) : "";

			checkBoxCalibrate10.Checked = m_Calibration.m_Reflectance10.m_IsAvailable;
			buttonCalibrate10.Enabled = m_Calibration.m_Reflectance10.m_IsAvailable;
			labelProbeNormalized10.Enabled = m_Calibration.m_Reflectance10.m_IsAvailable;
			labelProbeValue10.Text = m_Calibration.m_Reflectance10.m_IsAvailable ? m_Calibration.m_Reflectance10.m_LuminanceMeasured.ToString( Format ) : "";
			labelProbeNormalized10.Text = m_Calibration.m_Reflectance10.m_IsAvailable ? m_Calibration.m_Reflectance10.m_LuminanceNormalized.ToString( Format ) : "";
			labelProbeRelative10.Text = m_Calibration.m_Reflectance10.m_IsAvailable ? m_Calibration.m_Reflectance10.m_LuminanceRelative.ToString( Format ) : "";

			checkBoxCalibrate20.Checked = m_Calibration.m_Reflectance20.m_IsAvailable;
			buttonCalibrate20.Enabled = m_Calibration.m_Reflectance20.m_IsAvailable;
			labelProbeNormalized20.Enabled = m_Calibration.m_Reflectance20.m_IsAvailable;
			labelProbeValue20.Text = m_Calibration.m_Reflectance20.m_IsAvailable ? m_Calibration.m_Reflectance20.m_LuminanceMeasured.ToString( Format ) : "";
			labelProbeNormalized20.Text = m_Calibration.m_Reflectance20.m_IsAvailable ? m_Calibration.m_Reflectance20.m_LuminanceNormalized.ToString( Format ) : "";
			labelProbeRelative20.Text = m_Calibration.m_Reflectance20.m_IsAvailable ? m_Calibration.m_Reflectance20.m_LuminanceRelative.ToString( Format ) : "";

			checkBoxCalibrate50.Checked = m_Calibration.m_Reflectance50.m_IsAvailable;
			buttonCalibrate50.Enabled = m_Calibration.m_Reflectance50.m_IsAvailable;
			labelProbeNormalized50.Enabled = m_Calibration.m_Reflectance50.m_IsAvailable;
			labelProbeValue50.Text = m_Calibration.m_Reflectance50.m_IsAvailable ? m_Calibration.m_Reflectance50.m_LuminanceMeasured.ToString( Format ) : "";
			labelProbeNormalized50.Text = m_Calibration.m_Reflectance50.m_IsAvailable ? m_Calibration.m_Reflectance50.m_LuminanceNormalized.ToString( Format ) : "";
			labelProbeRelative50.Text = m_Calibration.m_Reflectance50.m_IsAvailable ? m_Calibration.m_Reflectance50.m_LuminanceRelative.ToString( Format ) : "";

			checkBoxCalibrate75.Checked = m_Calibration.m_Reflectance75.m_IsAvailable;
			buttonCalibrate75.Enabled = m_Calibration.m_Reflectance75.m_IsAvailable;
			labelProbeNormalized75.Enabled = m_Calibration.m_Reflectance75.m_IsAvailable;
			labelProbeValue75.Text = m_Calibration.m_Reflectance75.m_IsAvailable ? m_Calibration.m_Reflectance75.m_LuminanceMeasured.ToString( Format ) : "";
			labelProbeNormalized75.Text = m_Calibration.m_Reflectance75.m_IsAvailable ? m_Calibration.m_Reflectance75.m_LuminanceNormalized.ToString( Format ) : "";
			labelProbeRelative75.Text = m_Calibration.m_Reflectance75.m_IsAvailable ? m_Calibration.m_Reflectance75.m_LuminanceRelative.ToString( Format ) : "";

			checkBoxCalibrate99.Checked = m_Calibration.m_Reflectance99.m_IsAvailable;
			buttonCalibrate99.Enabled = m_Calibration.m_Reflectance99.m_IsAvailable;
			labelProbeNormalized99.Enabled = m_Calibration.m_Reflectance99.m_IsAvailable;
			labelProbeValue99.Text = m_Calibration.m_Reflectance99.m_IsAvailable ? m_Calibration.m_Reflectance99.m_LuminanceMeasured.ToString( Format ) : "";
			labelProbeNormalized99.Text = m_Calibration.m_Reflectance99.m_IsAvailable ? m_Calibration.m_Reflectance99.m_LuminanceNormalized.ToString( Format ) : "";
			labelProbeRelative99.Text = m_Calibration.m_Reflectance99.m_IsAvailable ? m_Calibration.m_Reflectance99.m_LuminanceRelative.ToString( Format ) : "";

			graphPanel.Calibration = m_Calibration;				// Update the graph
			referenceImagePanel.Calibration = m_Calibration;	// Update the image thumbnail

			bool	CanReCalibrate = false;
			if ( m_BitmapXYZ != null )
			{
				foreach ( CameraCalibration.Probe P in m_Calibration.m_Reflectances )
					if ( P.m_IsAvailable )
					{	// We have at least one available probe location to use
						CanReCalibrate = true;
						break;
					}
			}
			buttonReCalibrate.Enabled = CanReCalibrate;
		}

		private void checkBoxCalibrate02_CheckedChanged( object sender, EventArgs e )
		{
			m_Calibration.m_Reflectance02.m_IsAvailable = (sender as CheckBox).Checked;
			UpdateUIFromCalibration();
		}

		private void checkBoxCalibrate10_CheckedChanged( object sender, EventArgs e )
		{
			m_Calibration.m_Reflectance10.m_IsAvailable = (sender as CheckBox).Checked;
			UpdateUIFromCalibration();
		}

		private void checkBoxCalibrate20_CheckedChanged( object sender, EventArgs e )
		{
			m_Calibration.m_Reflectance20.m_IsAvailable = (sender as CheckBox).Checked;
			UpdateUIFromCalibration();
		}

		private void checkBoxCalibrate50_CheckedChanged( object sender, EventArgs e )
		{
			m_Calibration.m_Reflectance50.m_IsAvailable = (sender as CheckBox).Checked;
			UpdateUIFromCalibration();
		}

		private void checkBoxCalibrate75_CheckedChanged( object sender, EventArgs e )
		{
			m_Calibration.m_Reflectance75.m_IsAvailable = (sender as CheckBox).Checked;
			UpdateUIFromCalibration();
		}

		private void checkBoxCalibrate99_CheckedChanged( object sender, EventArgs e )
		{
			m_Calibration.m_Reflectance99.m_IsAvailable = (sender as CheckBox).Checked;
			UpdateUIFromCalibration();
		}

		private void buttonCalibrate02_Click( object sender, EventArgs e )
		{
			StartCalibrationPicking( m_Calibration.m_Reflectance02 );
		}

		private void buttonCalibrate10_Click( object sender, EventArgs e )
		{
			StartCalibrationPicking( m_Calibration.m_Reflectance10 );
		}

		private void buttonCalibrate20_Click( object sender, EventArgs e )
		{
			StartCalibrationPicking( m_Calibration.m_Reflectance20 );
		}

		private void buttonCalibrate50_Click( object sender, EventArgs e )
		{
			StartCalibrationPicking( m_Calibration.m_Reflectance50 );
		}

		private void buttonCalibrate75_Click( object sender, EventArgs e )
		{
			StartCalibrationPicking( m_Calibration.m_Reflectance75 );
		}

		private void buttonCalibrate99_Click( object sender, EventArgs e )
		{
			StartCalibrationPicking( m_Calibration.m_Reflectance99 );
		}

		private void checkBoxGraphLagrange_CheckedChanged( object sender, EventArgs e )
		{
			graphPanel.UseLagrange = checkBoxGraphLagrange.Checked;
		}

		private void buttonLoadCalibration_Click( object sender, EventArgs e )
		{
 			string	OldFileName = GetRegKey( "LastCalibrationFilename", m_ApplicationPath );
			openFileDialogCalibration.InitialDirectory = System.IO.Path.GetDirectoryName( OldFileName );
			openFileDialogCalibration.FileName = System.IO.Path.GetFileName( OldFileName );

			if ( openFileDialogCalibration.ShowDialog( this ) != DialogResult.OK )
 				return;

			SetRegKey( "LastCalibrationFilename", openFileDialogCalibration.FileName );

			try
			{
				CameraCalibration	NewCalibration = new CameraCalibration();
				NewCalibration.Load( new System.IO.FileInfo( openFileDialogCalibration.FileName ) );
				m_Calibration = NewCalibration;
				UpdateUIFromCalibration();
			}
			catch ( Exception _e )
			{
				MessageBox( "An error occurred while loading calibration file:\r\n\r\n", _e );
			}
		}

		private void buttonSaveCalibration_Click( object sender, EventArgs e )
		{
			if ( m_BitmapXYZ == null )
			{	// No image loaded you moron!
				MessageBox( "Can't save calibration as no image is currently loaded!", MessageBoxButtons.OK, MessageBoxIcon.Exclamation );
				return;
			}

			string	OldFileName = m_ImageFileName.FullName;// GetRegKey( "LastCalibrationFilename", m_ApplicationPath );
			saveFileDialogCalibration.InitialDirectory = System.IO.Path.GetDirectoryName( OldFileName );
			saveFileDialogCalibration.FileName = System.IO.Path.GetFileNameWithoutExtension( m_Calibration.m_ReferenceImageName ) + ".xml";

			if ( saveFileDialogCalibration.ShowDialog( this ) != DialogResult.OK )
				return;

			SetRegKey( "LastCalibrationFilename", saveFileDialogCalibration.FileName );

			try
			{
				// Save & update UI
				m_Calibration.Save( new System.IO.FileInfo( saveFileDialogCalibration.FileName ) );
				UpdateUIFromCalibration();
			}
			catch ( Exception _e )
			{
				MessageBox( "An error occurred while loading calibration file:", _e );
			}
		}

		private void buttonSetupDatabaseFolder_Click( object sender, EventArgs e )
		{
			string	OldPath = GetRegKey( "LastCalibrationDatabasePath", System.IO.Path.GetDirectoryName( m_ApplicationPath ) );
			folderBrowserDialogDatabaseLocation.SelectedPath = OldPath;
			if ( folderBrowserDialogDatabaseLocation.ShowDialog( this ) != DialogResult.OK )
				return;

			SetRegKey( "LastCalibrationDatabasePath", folderBrowserDialogDatabaseLocation.SelectedPath );

			ReloadDatabase();
		}

		private void buttonReCalibrate_Click( object sender, EventArgs e )
		{
			// Re-Calibrate every available probe
			bool	ProbesHaveSaturatedValues = false;
			bool	ProbesMissMeasurementDisc = false;
			foreach ( CameraCalibration.Probe P in m_Calibration.m_Reflectances )
				if ( P.m_MeasurementDiscIsAvailable )
				{
					float	BlackValues, SaturatedValues;
					float	MeasuredValue = IntegrateLuminance( P.m_MeasurementCenterX, P.m_MeasurementCenterY, P.m_MeasurementRadius, out BlackValues, out SaturatedValues );
					if ( BlackValues > BLACK_VALUES_TOLERANCE || SaturatedValues > SATURATED_VALUES_TOLERANCE )
					{	// Disable that probe as too many values are black or saturated
						P.m_IsAvailable = false;
						P.m_LuminanceMeasured = 0.0f;
						ProbesHaveSaturatedValues = true;
						continue;
					}

					// We have a valid measurement!
					P.m_IsAvailable = true;
					P.m_LuminanceMeasured = MeasuredValue;
				}
				else
				{	// Disable probe as it has no measurement info
					P.m_IsAvailable = false;
					P.m_LuminanceMeasured = 0.0f;
					ProbesMissMeasurementDisc = true;
				}

			// We now used the current image as reference for this calibration so commit its data
			CommitImageToCurrentCalibration();

			if ( ProbesHaveSaturatedValues )
				MessageBox( "Some probes have been disabled because the luminance measurement returned too many saturated or black values!", MessageBoxButtons.OK, MessageBoxIcon.Warning );
			if ( ProbesMissMeasurementDisc )
				MessageBox( "Some probes can't be measured because they're missing the sampling disc information!\r\nClick the \"Calibrate\" button to place the disk and calibrate manually.", MessageBoxButtons.OK, MessageBoxIcon.Warning );
		}

		#endregion

		#region Texture Generation

		private void buttonSaveCalibratedImage_Click( object sender, EventArgs e )
		{
			if ( m_Texture == null )
			{	// No image loaded you moron!
				MessageBox( "Can't save calibrated texture as no capture has been done yet!", MessageBoxButtons.OK, MessageBoxIcon.Exclamation );
				return;
			}

 			string	OldFileName = GetRegKey( "LastCalibratedTextureFilename", m_ImageFileName.FullName );
			saveFileDialogCalibratedImage.InitialDirectory = System.IO.Path.GetDirectoryName( OldFileName );
			saveFileDialogCalibratedImage.FileName = System.IO.Path.GetFileName( OldFileName );

			if ( saveFileDialogCalibratedImage.ShowDialog( this ) != DialogResult.OK )
 				return;

			SetRegKey( "LastCalibratedTextureFilename", saveFileDialogCalibratedImage.FileName );

			//////////////////////////////////////////////////////////////////////////
			// Save actual image
			try
			{
				System.IO.FileInfo	TargetFileName = new System.IO.FileInfo( saveFileDialogCalibratedImage.FileName );
				string	Extension = System.IO.Path.GetExtension( TargetFileName.FullName ).ToUpper();

				CalibratedTexture.TARGET_FORMAT	Format = CalibratedTexture.TARGET_FORMAT.PNG16;
				switch ( Extension )
				{
					case ".PNG": Format = CalibratedTexture.TARGET_FORMAT.PNG16; break;
					case ".TIF":
					case ".TIFF":
						Format = CalibratedTexture.TARGET_FORMAT.TIFF;
						break;
					default:
						throw new Exception( "Unsupported file extension!" );
				}
				m_Texture.SavePack( TargetFileName, Format );
				
			}
			catch ( Exception _e )
			{
				MessageBox( "An error occurred while saving the calibrated image:\r\n\r\n", _e );
			}
		}

		private void buttonCropTool_Click( object sender, EventArgs e )
		{
			outputPanel.CropRectangleEnabled = !outputPanel.CropRectangleEnabled;
			if ( outputPanel.CropRectangleEnabled )
				buttonCapture.Focus();	// So a simple press on return triggers the capture
		}

		private void buttonResetCrop_Click( object sender, EventArgs e )
		{
			outputPanel.ResetCropRectangle();
		}

		private void buttonCapture_Click( object sender, EventArgs e )
		{
			if ( m_BitmapXYZ == null )
			{	// No image loaded you moron!
				MessageBox( "Can't capture as no image is currently loaded!", MessageBoxButtons.OK, MessageBoxIcon.Exclamation );
				return;
			}
			if ( !PrepareDatabase() )
				return;

			//////////////////////////////////////////////////////////////////////////
			// Prepare parameters
			CalibratedTexture.CaptureParms	Parms = new CalibratedTexture.CaptureParms() {
				SourceImageName = m_ImageFileName.FullName,

				ISOSpeed = floatTrackbarControlISOSpeed.Value,
				ShutterSpeed = floatTrackbarControlShutterSpeed.Value,
				Aperture = floatTrackbarControlAperture.Value,

				CropSource = !outputPanel.IsDefaultCropRectangle,
				CropRectangleCenter = new float2( outputPanel.CropRectangeCenter.x, outputPanel.CropRectangeCenter.y ),
				CropRectangleHalfSize = new float2( outputPanel.CropRectangeHalfSize.x, outputPanel.CropRectangeHalfSize.y ),
				CropRectangleRotation = outputPanel.CropRectangeRotation,
			};

			//////////////////////////////////////////////////////////////////////////
			// Go!
			try
			{
				CalibratedTexture	Tex = new CalibratedTexture();
				Tex.Capture( m_BitmapXYZ, m_CalibrationDatabase, Parms );
				
				m_Texture = Tex;

				// Use the form's swatch panels as default swatch size
				m_Texture.SwatchWidth = panelCustomSwatch0.Width-2;
				m_Texture.SwatchHeight = panelCustomSwatch0.Height-2;

				// Update UI
				resultTexturePanel.CalibratedTexture = m_Texture;
				buttonSaveCalibratedImage.Enabled = true;

				m_SwatchMin.m_xyY = m_Texture.SwatchMin.xyY;
				m_SwatchMin.UpdateSwatchColor();
				m_SwatchMax.m_xyY = m_Texture.SwatchMax.xyY;
				m_SwatchMax.UpdateSwatchColor();
				m_SwatchAvg.m_xyY = m_Texture.SwatchAvg.xyY;
				m_SwatchAvg.UpdateSwatchColor();
			}
			catch ( Exception _e )
			{
				MessageBox( "An error occurred during capture:\r\n\r\n", _e );
			}
		}

		private void StartColorPicking( int _CustomSwatchIndex )
		{
			if ( m_BitmapXYZ == null )
			{	// No image loaded you moron!
				MessageBox( "Can't start color picking for swatch as no image is currently loaded!", MessageBoxButtons.OK, MessageBoxIcon.Exclamation );
				return;
			}
			if ( m_Texture == null )
			{	// No texture captured you moron!
				MessageBox( "Can't start color picking for swatch as no texture has been captured yet!", MessageBoxButtons.OK, MessageBoxIcon.Exclamation );
				return;
			}
			if ( !PrepareDatabase() )
				return;

			CustomSwatch	CS = m_CustomSwatches[_CustomSwatchIndex];

			CS.m_CheckBox.Checked = true;	// Automatically enable color swatch if the user bothered picking a color

			resultTexturePanel.StartSwatchColorPicking( ( float2 _TopLeft, float2 _BottomRight ) => {

				CS.m_LocationTopLeft = new float2( _TopLeft.x, _TopLeft.y );
				CS.m_LocationBottomRight = new float2( _BottomRight.x, _BottomRight.y );
				CS.UpdateSwatchColor();
			},

			( float2 _TopLeft, float2 _BottomRight ) => {
				checkBoxCustomSwatch0_CheckedChanged( null, EventArgs.Empty );	// Rebuild custom swatches when picking is done
			} );
		}

		private void checkBoxCustomSwatch0_CheckedChanged( object sender, EventArgs e )
		{
			if ( m_Texture == null )
				return;

			// Rebuild custom swatches for the texture
			List<float4>	UsedSwatchesLocations = new List<float4>();
			foreach ( CustomSwatch S in m_CustomSwatches )
			{
				if ( !S.m_CheckBox.Checked || S.m_LocationTopLeft.x < 0.0f || S.m_LocationTopLeft.x > 1.0f || S.m_LocationTopLeft.y < 0.0f || S.m_LocationTopLeft.y > 1.0f )
					continue;	// Unused...
				UsedSwatchesLocations.Add( new float4( S.m_LocationTopLeft.x, S.m_LocationTopLeft.y, S.m_LocationBottomRight.x, S.m_LocationBottomRight.y ) );
			}

			m_Texture.BuildCustomSwatches( UsedSwatchesLocations.ToArray() );

			foreach ( CustomSwatch S in m_CustomSwatches )
				S.UpdateSwatchColor();

			// Repaint result texture so it shows
			resultTexturePanel.Invalidate();

		}

		private void panelCustomSwatch0_Click( object sender, EventArgs e )
		{
			StartColorPicking( 0 );
		}

		private void panelCustomSwatch1_Click( object sender, EventArgs e )
		{
			StartColorPicking( 1 );
		}

		private void panelCustomSwatch2_Click( object sender, EventArgs e )
		{
			StartColorPicking( 2 );
		}

		private void panelCustomSwatch3_Click( object sender, EventArgs e )
		{
			StartColorPicking( 3 );
		}

		private void panelCustomSwatch4_Click( object sender, EventArgs e )
		{
			StartColorPicking( 4 );
		}

		private void panelCustomSwatch5_Click( object sender, EventArgs e )
		{
			StartColorPicking( 5 );
		}

		private void panelCustomSwatch6_Click( object sender, EventArgs e )
		{
			StartColorPicking( 6 );
		}

		private void panelCustomSwatch7_Click( object sender, EventArgs e )
		{
			StartColorPicking( 7 );
		}

		private void panelCustomSwatch8_Click( object sender, EventArgs e )
		{
			StartColorPicking( 8 );
		}

		private void floatTrackbarControlShotInfos_SliderDragStop( Nuaj.Cirrus.Utility.FloatTrackbarControl _Sender, float _fStartValue )
		{
			PrepareDatabase();

			// Update white reflectance to show correction factor
			UpdateWhiteReflectanceUI();
		}

		private void resultTexturePanel_MouseMove( object sender, MouseEventArgs e )
		{
			labelCapturedReflectance.Text = "";
			if ( m_Texture == null )
				return;

			RectangleF	R = resultTexturePanel.ImageClientRectangle;
			float	X = (e.X - R.Left) / R.Width;
			float	Y = (e.Y - R.Top) / R.Height;
			if ( X < 0.0f || X > 1.0f || Y < 0.0f || Y > 1.0f )
				return;

			X *= m_Texture.Texture.Width;
			Y *= m_Texture.Texture.Height;

			float4	XYZ = m_Texture.Texture.BilinearSample( X, Y );
			float3	xyY = Bitmap2.ColorProfile.XYZ2xyY( (float3) XYZ );
			labelCapturedReflectance.Text = xyY.ToString();
		}

		private void panelSwatchMin_MouseMove( object sender, MouseEventArgs e )
		{
			Swatch	S = null;
			if ( sender == panelSwatchMin )
				S = m_SwatchMin;
			else if ( sender == panelSwatchMax )
				S = m_SwatchMax;
			else if ( sender == panelSwatchAverage )
				S = m_SwatchAvg;
			else
			{
				foreach ( Swatch CS in m_CustomSwatches )
					if ( sender == CS.m_Panel )
					{
						S = CS;
						break;
					}
			}

			labelCapturedSwatchRGB.Text = S != null ? S.m_RGB.ToString() : "";
			labelCapturedSwatchxyY.Text = S != null ? S.m_xyY.ToString() : "";
		}

		#endregion

		#region Color Correction

		//////////////////////////////////////////////////////////////////////////
		// White Reflectance Reference
		//
		private void buttonPickWhiteReflectance_Click( object sender, EventArgs e )
		{
			if ( m_BitmapXYZ == null )
			{	// No image loaded you moron!
				MessageBox( "Can't pick white reflectance as no image is currently loaded!", MessageBoxButtons.OK, MessageBoxIcon.Exclamation );
				return;
			}

			outputPanel.StartWhiteReflectancePicking( ( float2 _UV ) => {

				float4	XYZ = m_BitmapXYZ.BilinearSample( _UV.x * m_BitmapXYZ.Width, _UV.y * m_BitmapXYZ.Height );
				float3	xyY = Bitmap2.ColorProfile.XYZ2xyY( (float3) XYZ );

				// Compute the correction factor to apply to further image
				m_CalibrationDatabase.WhiteReflectanceReference = xyY.z;

				UpdateWhiteReflectanceUI();
			} );
		}

		private void buttonLoadWhiteReflectanceReference_Click( object sender, EventArgs e )
		{
			string	OldFileName = GetRegKey( "LastWhiteReflectanceFilename", m_ImageFileName != null ? m_ImageFileName.FullName : m_ApplicationPath );
			openFileDialogWhiteReflectance.InitialDirectory = System.IO.Path.GetDirectoryName( OldFileName );
			openFileDialogWhiteReflectance.FileName = System.IO.Path.GetFileNameWithoutExtension( OldFileName ) + ".whiteRef";

			if ( openFileDialogWhiteReflectance.ShowDialog( this ) != DialogResult.OK )
 				return;

			SetRegKey( "LastWhiteReflectanceFilename", openFileDialogWhiteReflectance.FileName );
			SetRegKey( "ReloadWhiteReflectanceOnStartup", "true" );

			System.IO.FileInfo	WhiteRefFileName = new System.IO.FileInfo( openFileDialogWhiteReflectance.FileName );
			LoadWhiteReflectanceFile( WhiteRefFileName, true );
		}

		private void buttonSaveWhiteReflectanceReference_Click( object sender, EventArgs e )
		{
			string	OldFileName =  m_ImageFileName.FullName;
			saveFileDialogWhiteReflectance.InitialDirectory = System.IO.Path.GetDirectoryName( OldFileName );
			saveFileDialogWhiteReflectance.FileName = System.IO.Path.GetFileNameWithoutExtension( OldFileName ) + ".whiteRef";

			if ( saveFileDialogWhiteReflectance.ShowDialog( this ) != DialogResult.OK )
 				return;

			SetRegKey( "LastWhiteReflectanceFilename", saveFileDialogWhiteReflectance.FileName );
			SetRegKey( "ReloadWhiteReflectanceOnStartup", "true" );

			try
			{
				System.IO.FileInfo	WhiteRefFileName = new System.IO.FileInfo( saveFileDialogWhiteReflectance.FileName );

				// Save
				System.Xml.XmlDocument	Doc = new System.Xml.XmlDocument();
				System.Xml.XmlElement	Root = Doc.CreateElement( "WhiteReflectance" );
				Doc.AppendChild( Root );
				Root.SetAttribute( "Value", m_CalibrationDatabase.WhiteReflectanceReference.ToString() );
				Doc.Save( WhiteRefFileName.FullName );
			}
			catch ( Exception _e )
			{
				MessageBox( "An error occurred while saving white reflectance file:\r\n\r\n", _e );
			}
		}

		private void buttonResetWhiteReflectance_Click( object sender, EventArgs e )
		{
			m_CalibrationDatabase.WhiteReflectanceReference = -1.0f;	// Will reset the factor

			SetRegKey( "ReloadWhiteReflectanceOnStartup", "false" );	// Prevent auto load on startup

			UpdateWhiteReflectanceUI();
		}

		private void UpdateWhiteReflectanceUI()
		{
			labelWhiteReflectance.Text = m_CalibrationDatabase.WhiteReflectanceReference.ToString() + " Correction=" + m_CalibrationDatabase.WhiteReflectanceCorrectionFactor.ToString();

			bool	IsValidRef = m_CalibrationDatabase.WhiteReflectanceReference > 0.0f;
			buttonSaveWhiteReflectanceReference.Enabled = IsValidRef;
			buttonResetWhiteReflectance.Enabled = IsValidRef;

			// Also update all existing color swatches
			foreach ( CustomSwatch S in m_CustomSwatches )
				S.UpdateSwatchColor();
		}

		//////////////////////////////////////////////////////////////////////////
		// White Reference Image
		//
		private void buttonPickWhiteRefImage_Click( object sender, EventArgs e )
		{
			if ( m_BitmapXYZ == null )
			{	// No image loaded you moron!
				MessageBox( "Can't pick white reference as no image is currently loaded!", MessageBoxButtons.OK, MessageBoxIcon.Exclamation );
				return;
			}

			try
			{
				int	W, H;
				if ( m_BitmapXYZ.Width > m_BitmapXYZ.Height )
				{
					W = DEFAULT_WHITE_REFERENCE_IMAGE_SIZE;
					H = W * m_BitmapXYZ.Height / m_BitmapXYZ.Width;
				}
				else
				{
					H = DEFAULT_WHITE_REFERENCE_IMAGE_SIZE;
					W = H * m_BitmapXYZ.Width / m_BitmapXYZ.Height;
				}

				// Find the maximum luminance in the image that we'll use as a normalizer
				float	MaxY = 0.0f;
				for ( int Y=0; Y < H; Y++ )
					for ( int X=0; X < W; X++ )
					{
						float4	XYZ = m_BitmapXYZ.BilinearSample( m_BitmapXYZ.Width * (float) X / W, m_BitmapXYZ.Height * (float) Y / H );
						MaxY = Math.Max( MaxY, XYZ.y );
					}

				// Build the actual normalized bitmap
				Bitmap2	WhiteRef = new Bitmap2( W, H );
				for ( int Y=0; Y < H; Y++ )
					for ( int X=0; X < W; X++ )
					{
						float4	XYZ = m_BitmapXYZ.BilinearSample( m_BitmapXYZ.Width * (float) X / W, m_BitmapXYZ.Height * (float) Y / H );
						float3	xyY = Bitmap2.ColorProfile.XYZ2xyY( (float3) XYZ );
								xyY.z /= MaxY;	// Normalize
						XYZ = new float4( Bitmap2.ColorProfile.xyY2XYZ( xyY ), XYZ.w );
						WhiteRef.ContentXYZ[X,Y] = XYZ;
					}

				// Assign to the database
				m_CalibrationDatabase.WhiteReferenceImage = WhiteRef;

				UpdateWhiteReferenceImageUI();
			}
			catch ( Exception _e )
			{
				MessageBox( "An error occurred while creating the white reference image:\r\n\r\n", _e );
			}
		}

		private void buttonLoadWhiteRefImage_Click( object sender, EventArgs e )
		{
			string	OldFileName = GetRegKey( "LastWhiteReferenceImageFilename", m_ImageFileName != null ? System.IO.Path.GetDirectoryName( m_ImageFileName.FullName ) + System.IO.Path.GetFileNameWithoutExtension( m_ImageFileName.FullName ) + ".png" : m_ApplicationPath );
			openFileDialogWhiteRefImage.InitialDirectory = System.IO.Path.GetDirectoryName( OldFileName );
			openFileDialogWhiteRefImage.FileName = System.IO.Path.GetFileName( OldFileName );

			if ( openFileDialogWhiteRefImage.ShowDialog( this ) != DialogResult.OK )
 				return;

			SetRegKey( "LastWhiteReferenceImageFilename", openFileDialogWhiteRefImage.FileName );
			SetRegKey( "ReloadWhiteReferenceImageOnStartup", "true" );

			System.IO.FileInfo	WhiteRefFileName = new System.IO.FileInfo( openFileDialogWhiteRefImage.FileName );
			LoadWhiteReferenceImage( WhiteRefFileName, true );
		}

		private void buttonSaveWhiteRefImage_Click( object sender, EventArgs e )
		{
			string	OldFileName = GetRegKey( "LastWhiteReferenceImageFilename", m_ImageFileName != null ? System.IO.Path.GetDirectoryName( m_ImageFileName.FullName ) + System.IO.Path.GetFileNameWithoutExtension( m_ImageFileName.FullName ) + ".png" : m_ApplicationPath );
			saveFileDialogWhiteRefImage.InitialDirectory = System.IO.Path.GetDirectoryName( OldFileName );
			saveFileDialogWhiteRefImage.FileName = System.IO.Path.GetFileName( OldFileName );

			if ( saveFileDialogWhiteRefImage.ShowDialog( this ) != DialogResult.OK )
 				return;

			SetRegKey( "LastWhiteReferenceImageFilename", saveFileDialogWhiteRefImage.FileName );
			SetRegKey( "ReloadWhiteReferenceImageOnStartup", "true" );

			try
			{
				System.IO.FileInfo	WhiteRefFileName = new System.IO.FileInfo( saveFileDialogWhiteReflectance.FileName );

				using ( System.IO.FileStream S = WhiteRefFileName.Create() )
					m_CalibrationDatabase.WhiteReferenceImage.Save( S, Bitmap2.FILE_TYPE.PNG, Bitmap2.FORMAT_FLAGS.GRAY | Bitmap2.FORMAT_FLAGS.SAVE_16BITS_UNORM );
			}
			catch ( Exception _e )
			{
				MessageBox( "An error occurred while saving white reflectance file:\r\n\r\n", _e );
			}
		}

		private void buttonResetWhiteRefImage_Click( object sender, EventArgs e )
		{
			SetRegKey( "ReloadWhiteReferenceImageOnStartup", "false" );	// Prevent auto load on startup

			m_CalibrationDatabase.WhiteReferenceImage = null;

			UpdateWhiteReferenceImageUI();
		}

		private void UpdateWhiteReferenceImageUI()
		{
//			labelWhiteReflectance.Text = m_CalibrationDatabase.WhiteReflectanceReference.ToString() + " Correction=" + m_CalibrationDatabase.WhiteReflectanceCorrectionFactor.ToString();

			whiteImageReferencePanel.WhiteReferenceImage = m_CalibrationDatabase.WhiteReferenceImage;

			bool	IsValidRef = m_CalibrationDatabase.WhiteReferenceImage != null;
			buttonSaveWhiteReflectanceReference.Enabled = IsValidRef;
			buttonResetWhiteReflectance.Enabled = IsValidRef;
		}

		#endregion

		#endregion
	}
}


#region Source code from http://cybercom.net/~dcoffin/dcraw/decompress.c
// 	/*
//    Simple reference decompresser for Canon digital cameras.
//    Outputs raw 16-bit CCD data, no header, native byte order.
// 
//    $Revision: 1.12 $
//    $Date: 2004/08/06 00:08:01 $
// */
// 
// #include <stdio.h>
// #include <stdlib.h>
// #include <string.h>
// 
// typedef unsigned char uchar;
// 
// /* Global Variables */
// 
// FILE *ifp;
// short order;
// int height, width, table, lowbits;
// char name[64];
// 
// struct decode {
//   struct decode *branch[2];
//   int leaf;
// } first_decode[32], second_decode[512];
// 
// /*
//    Get a 2-byte integer, making no assumptions about CPU byte order.
//    Nor should we assume that the compiler evaluates left-to-right.
//  */
// short fget2 (FILE *f)
// {
//   register uchar a, b;
// 
//   a = fgetc(f);
//   b = fgetc(f);
//   if (order == 0x4d4d)		/* "MM" means big-endian */
//     return (a << 8) + b;
//   else				/* "II" means little-endian */
//     return a + (b << 8);
// }
// 
// /*
//    Same for a 4-byte integer.
//  */
// int fget4 (FILE *f)
// {
//   register uchar a, b, c, d;
// 
//   a = fgetc(f);
//   b = fgetc(f);
//   c = fgetc(f);
//   d = fgetc(f);
//   if (order == 0x4d4d)
//     return (a << 24) + (b << 16) + (c << 8) + d;
//   else
//     return a + (b << 8) + (c << 16) + (d << 24);
// }
// 
// /*
//    Parse the CIFF structure
//  */
// void parse (int offset, int length)
// {
//   int tboff, nrecs, i, type, len, roff, aoff, save;
// 
//   fseek (ifp, offset+length-4, SEEK_SET);
//   tboff = fget4(ifp) + offset;
//   fseek (ifp, tboff, SEEK_SET);
//   nrecs = fget2(ifp);
//   for (i = 0; i < nrecs; i++) {
//     type = fget2(ifp);
//     len  = fget4(ifp);
//     roff = fget4(ifp);
//     aoff = offset + roff;
//     save = ftell(ifp);
//     if (type == 0x080a) {		/* Get the camera name */
//       fseek (ifp, aoff, SEEK_SET);
//       while (fgetc(ifp));
//       fread (name, 64, 1, ifp);
//     }
//     if (type == 0x1031) {		/* Get the width and height */
//       fseek (ifp, aoff+2, SEEK_SET);
//       width  = fget2(ifp);
//       height = fget2(ifp);
//     }
//     if (type == 0x1835) {		/* Get the decoder table */
//       fseek (ifp, aoff, SEEK_SET);
//       table = fget4(ifp);
//     }
//     if (type >> 8 == 0x28 || type >> 8 == 0x30)	/* Get sub-tables */
//       parse (aoff, len);
//     fseek (ifp, save, SEEK_SET);
//   }
// }
// 
// /*
//    Return 0 if the image starts with compressed data,
//    1 if it starts with uncompressed low-order bits.
// 
//    In Canon compressed data, 0xff is always followed by 0x00.
//  */
// int canon_has_lowbits()
// {
//   uchar test[0x4000];
//   int ret=1, i;
// 
//   fseek (ifp, 0, SEEK_SET);
//   fread (test, 1, sizeof test, ifp);
//   for (i=540; i < sizeof test - 1; i++)
//     if (test[i] == 0xff) {
//       if (test[i+1]) return 1;
//       ret=0;
//     }
//   return ret;
// }
// 
// /*
//    Open a CRW file, identify which camera created it, and set
//    global variables accordingly.  Returns nonzero if an error occurs.
//  */
// int open_and_id(char *fname)
// {
//   char head[8];
//   int hlen;
// 
//   ifp = fopen(fname,"rb");
//   if (!ifp) {
//     perror(fname);
//     return 1;
//   }
//   order = fget2(ifp);
//   hlen  = fget4(ifp);
// 
//   fread (head, 1, 8, ifp);
//   if (memcmp(head,"HEAPCCDR",8) || (order != 0x4949 && order != 0x4d4d)) {
//     fprintf(stderr,"%s is not a Canon CRW file.\n",fname);
//     return 1;
//   }
// 
//   name[0] = 0;
//   table = -1;
//   fseek (ifp, 0, SEEK_END);
//   parse (hlen, ftell(ifp) - hlen);
//   lowbits = canon_has_lowbits();
// 
//   fprintf(stderr,"name = %s, width = %d, height = %d, table = %d, bpp = %d\n",
// 	name, width, height, table, 10+lowbits*2);
//   if (table < 0) {
//     fprintf(stderr,"Cannot decompress %s!!\n",fname);
//     return 1;
//   }
//   return 0;
// }
// 
// /*
//    A rough description of Canon's compression algorithm:
// 
// +  Each pixel outputs a 10-bit sample, from 0 to 1023.
// +  Split the data into blocks of 64 samples each.
// +  Subtract from each sample the value of the sample two positions
//    to the left, which has the same color filter.  From the two
//    leftmost samples in each row, subtract 512.
// +  For each nonzero sample, make a token consisting of two four-bit
//    numbers.  The low nibble is the number of bits required to
//    represent the sample, and the high nibble is the number of
//    zero samples preceding this sample.
// +  Output this token as a variable-length bitstring using
//    one of three tablesets.  Follow it with a fixed-length
//    bitstring containing the sample.
// 
//    The "first_decode" table is used for the first sample in each
//    block, and the "second_decode" table is used for the others.
//  */
// 
// /*
//    Construct a decode tree according the specification in *source.
//    The first 16 bytes specify how many codes should be 1-bit, 2-bit
//    3-bit, etc.  Bytes after that are the leaf values.
// 
//    For example, if the source is
// 
//     { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,
//       0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff  },
// 
//    then the code is
// 
// 	00		0x04
// 	010		0x03
// 	011		0x05
// 	100		0x06
// 	101		0x02
// 	1100		0x07
// 	1101		0x01
// 	11100		0x08
// 	11101		0x09
// 	11110		0x00
// 	111110		0x0a
// 	1111110		0x0b
// 	1111111		0xff
//  */
// void make_decoder(struct decode *dest, const uchar *source, int level)
// {
//   static struct decode *free;	/* Next unused node */
//   static int leaf;		/* no. of leaves already added */
//   int i, next;
// 
//   if (level==0) {
//     free = dest;
//     leaf = 0;
//   }
//   free++;
// /*
//    At what level should the next leaf appear?
//  */
//   for (i=next=0; i <= leaf && next < 16; )
//     i += source[next++];
// 
//   if (i > leaf)
//     if (level < next) {		/* Are we there yet? */
//       dest->branch[0] = free;
//       make_decoder(free,source,level+1);
//       dest->branch[1] = free;
//       make_decoder(free,source,level+1);
//     } else
//       dest->leaf = source[16 + leaf++];
// }
// 
// void init_tables(unsigned table)
// {
//   static const uchar first_tree[3][29] = {
//     { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,
//       0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff  },
// 
//     { 0,2,2,3,1,1,1,1,2,0,0,0,0,0,0,0,
//       0x03,0x02,0x04,0x01,0x05,0x00,0x06,0x07,0x09,0x08,0x0a,0x0b,0xff  },
// 
//     { 0,0,6,3,1,1,2,0,0,0,0,0,0,0,0,0,
//       0x06,0x05,0x07,0x04,0x08,0x03,0x09,0x02,0x00,0x0a,0x01,0x0b,0xff  },
//   };
// 
//   static const uchar second_tree[3][180] = {
//     { 0,2,2,2,1,4,2,1,2,5,1,1,0,0,0,139,
//       0x03,0x04,0x02,0x05,0x01,0x06,0x07,0x08,
//       0x12,0x13,0x11,0x14,0x09,0x15,0x22,0x00,0x21,0x16,0x0a,0xf0,
//       0x23,0x17,0x24,0x31,0x32,0x18,0x19,0x33,0x25,0x41,0x34,0x42,
//       0x35,0x51,0x36,0x37,0x38,0x29,0x79,0x26,0x1a,0x39,0x56,0x57,
//       0x28,0x27,0x52,0x55,0x58,0x43,0x76,0x59,0x77,0x54,0x61,0xf9,
//       0x71,0x78,0x75,0x96,0x97,0x49,0xb7,0x53,0xd7,0x74,0xb6,0x98,
//       0x47,0x48,0x95,0x69,0x99,0x91,0xfa,0xb8,0x68,0xb5,0xb9,0xd6,
//       0xf7,0xd8,0x67,0x46,0x45,0x94,0x89,0xf8,0x81,0xd5,0xf6,0xb4,
//       0x88,0xb1,0x2a,0x44,0x72,0xd9,0x87,0x66,0xd4,0xf5,0x3a,0xa7,
//       0x73,0xa9,0xa8,0x86,0x62,0xc7,0x65,0xc8,0xc9,0xa1,0xf4,0xd1,
//       0xe9,0x5a,0x92,0x85,0xa6,0xe7,0x93,0xe8,0xc1,0xc6,0x7a,0x64,
//       0xe1,0x4a,0x6a,0xe6,0xb3,0xf1,0xd3,0xa5,0x8a,0xb2,0x9a,0xba,
//       0x84,0xa4,0x63,0xe5,0xc5,0xf3,0xd2,0xc4,0x82,0xaa,0xda,0xe4,
//       0xf2,0xca,0x83,0xa3,0xa2,0xc3,0xea,0xc2,0xe2,0xe3,0xff,0xff  },
// 
//     { 0,2,2,1,4,1,4,1,3,3,1,0,0,0,0,140,
//       0x02,0x03,0x01,0x04,0x05,0x12,0x11,0x06,
//       0x13,0x07,0x08,0x14,0x22,0x09,0x21,0x00,0x23,0x15,0x31,0x32,
//       0x0a,0x16,0xf0,0x24,0x33,0x41,0x42,0x19,0x17,0x25,0x18,0x51,
//       0x34,0x43,0x52,0x29,0x35,0x61,0x39,0x71,0x62,0x36,0x53,0x26,
//       0x38,0x1a,0x37,0x81,0x27,0x91,0x79,0x55,0x45,0x28,0x72,0x59,
//       0xa1,0xb1,0x44,0x69,0x54,0x58,0xd1,0xfa,0x57,0xe1,0xf1,0xb9,
//       0x49,0x47,0x63,0x6a,0xf9,0x56,0x46,0xa8,0x2a,0x4a,0x78,0x99,
//       0x3a,0x75,0x74,0x86,0x65,0xc1,0x76,0xb6,0x96,0xd6,0x89,0x85,
//       0xc9,0xf5,0x95,0xb4,0xc7,0xf7,0x8a,0x97,0xb8,0x73,0xb7,0xd8,
//       0xd9,0x87,0xa7,0x7a,0x48,0x82,0x84,0xea,0xf4,0xa6,0xc5,0x5a,
//       0x94,0xa4,0xc6,0x92,0xc3,0x68,0xb5,0xc8,0xe4,0xe5,0xe6,0xe9,
//       0xa2,0xa3,0xe3,0xc2,0x66,0x67,0x93,0xaa,0xd4,0xd5,0xe7,0xf8,
//       0x88,0x9a,0xd7,0x77,0xc4,0x64,0xe2,0x98,0xa5,0xca,0xda,0xe8,
//       0xf3,0xf6,0xa9,0xb2,0xb3,0xf2,0xd2,0x83,0xba,0xd3,0xff,0xff  },
// 
//     { 0,0,6,2,1,3,3,2,5,1,2,2,8,10,0,117,
//       0x04,0x05,0x03,0x06,0x02,0x07,0x01,0x08,
//       0x09,0x12,0x13,0x14,0x11,0x15,0x0a,0x16,0x17,0xf0,0x00,0x22,
//       0x21,0x18,0x23,0x19,0x24,0x32,0x31,0x25,0x33,0x38,0x37,0x34,
//       0x35,0x36,0x39,0x79,0x57,0x58,0x59,0x28,0x56,0x78,0x27,0x41,
//       0x29,0x77,0x26,0x42,0x76,0x99,0x1a,0x55,0x98,0x97,0xf9,0x48,
//       0x54,0x96,0x89,0x47,0xb7,0x49,0xfa,0x75,0x68,0xb6,0x67,0x69,
//       0xb9,0xb8,0xd8,0x52,0xd7,0x88,0xb5,0x74,0x51,0x46,0xd9,0xf8,
//       0x3a,0xd6,0x87,0x45,0x7a,0x95,0xd5,0xf6,0x86,0xb4,0xa9,0x94,
//       0x53,0x2a,0xa8,0x43,0xf5,0xf7,0xd4,0x66,0xa7,0x5a,0x44,0x8a,
//       0xc9,0xe8,0xc8,0xe7,0x9a,0x6a,0x73,0x4a,0x61,0xc7,0xf4,0xc6,
//       0x65,0xe9,0x72,0xe6,0x71,0x91,0x93,0xa6,0xda,0x92,0x85,0x62,
//       0xf3,0xc5,0xb2,0xa4,0x84,0xba,0x64,0xa5,0xb3,0xd2,0x81,0xe5,
//       0xd3,0xaa,0xc4,0xca,0xf2,0xb1,0xe4,0xd1,0x83,0x63,0xea,0xc3,
//       0xe2,0x82,0xf1,0xa3,0xc2,0xa1,0xc1,0xe3,0xa2,0xe1,0xff,0xff  }
//   };
// 
//   if (table > 2) table = 2;
//   memset( first_decode, 0, sizeof first_decode);
//   memset(second_decode, 0, sizeof second_decode);
//   make_decoder( first_decode,  first_tree[table], 0);
//   make_decoder(second_decode, second_tree[table], 0);
// }
// 
// #if 0
// writebits (int val, int nbits)
// {
//   val <<= 32 - nbits;
//   while (nbits--) {
//     putchar(val & 0x80000000 ? '1':'0');
//     val <<= 1;
//   }
// }
// #endif
// 
// /*
//    getbits(-1) initializes the buffer
//    getbits(n) where 0 <= n <= 25 returns an n-bit integer
// */
// unsigned long getbits(int nbits)
// {
//   static unsigned long bitbuf=0, ret=0;
//   static int vbits=0;
//   unsigned char c;
// 
//   if (nbits == 0) return 0;
//   if (nbits == -1)
//     ret = bitbuf = vbits = 0;
//   else {
//     ret = bitbuf << (32 - vbits) >> (32 - nbits);
//     vbits -= nbits;
//   }
//   while (vbits < 25) {
//     c=fgetc(ifp);
//     bitbuf = (bitbuf << 8) + c;
//     if (c == 0xff) fgetc(ifp);	/* always extra 00 after ff */
//     vbits += 8;
//   }
//   return ret;
// }
// 
// int main(int argc, char **argv)
// {
//   struct decode *decode, *dindex;
//   int i, j, leaf, len, diff, diffbuf[64], r, save;
//   int carry=0, column=0, base[2];
//   unsigned short outbuf[64];
//   uchar c;
// 
//   if (argc < 2) {
//     fprintf(stderr,"Usage:  %s file.crw\n",argv[0]);
//     exit(1);
//   }
//   if (open_and_id(argv[1]))
//     exit(1);
// 
//   init_tables(table);
// 
//   fseek (ifp, 540 + lowbits*height*width/4, SEEK_SET);
//   getbits(-1);			/* Prime the bit buffer */
// 
//   while (column < width * height) {
//     memset(diffbuf,0,sizeof diffbuf);
//     decode = first_decode;
//     for (i=0; i < 64; i++ ) {
// 
//       for (dindex=decode; dindex->branch[0]; )
// 			dindex = dindex->branch[getbits(1)];
//       leaf = dindex->leaf;
//       decode = second_decode;
// 
//       if (leaf == 0 && i) break;
//       if (leaf == 0xff) continue;
//       i  += leaf >> 4;
//       len = leaf & 15;
//       if (len == 0) continue;
//       diff = getbits(len);
//       if ((diff & (1 << (len-1))) == 0)
// 	diff -= (1 << len) - 1;
//       if (i < 64) diffbuf[i] = diff;
//     }
//     diffbuf[0] += carry;
//     carry = diffbuf[0];
//     for (i=0; i < 64; i++ ) {
//       if (column++ % width == 0)
// 	base[0] = base[1] = 512;
//       outbuf[i] = ( base[i & 1] += diffbuf[i] );
//     }
//     if (lowbits) {
//       save = ftell(ifp);
//       fseek (ifp, (column-64)/4 + 26, SEEK_SET);
//       for (i=j=0; j < 64/4; j++ ) {
// 	c = fgetc(ifp);
// 	for (r = 0; r < 8; r += 2)
// 	  outbuf[i++] = (outbuf[i] << 2) + ((c >> r) & 3);
//       }
//       fseek (ifp, save, SEEK_SET);
//     }
//     fwrite(outbuf,2,64,stdout);
//   }
//   return 0;
// }

#endregion

#region Source code from http://cybercom.net/~dcoffin/dcraw/dcraw.c

// unsigned CLASS getbithuff (int nbits, ushort *huff)
// {
//   static unsigned bitbuf=0;
//   static int vbits=0, reset=0;
//   unsigned c;
// 
//   if (nbits > 25) return 0;
//   if (nbits < 0)
//     return bitbuf = vbits = reset = 0;
//   if (nbits == 0 || vbits < 0) return 0;
//   while (!reset && vbits < nbits && (c = fgetc(ifp)) != EOF &&
//     !(reset = zero_after_ff && c == 0xff && fgetc(ifp))) {
//     bitbuf = (bitbuf << 8) + (uchar) c;
//     vbits += 8;
//   }
//   c = bitbuf << (32-vbits) >> (32-nbits);
//   if (huff) {
//     vbits -= huff[c] >> 8;
//     c = (uchar) huff[c];
//   } else
//     vbits -= nbits;
//   if (vbits < 0) derror();
//   return c;
// }
// 
// #define getbits(n) getbithuff(n,0)
// #define gethuff(h) getbithuff(*h,h+1)
// 
// /*
//    Construct a decode tree according the specification in *source.
//    The first 16 bytes specify how many codes should be 1-bit, 2-bit
//    3-bit, etc.  Bytes after that are the leaf values.
// 
//    For example, if the source is
// 
//     { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,
//       0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff  },
// 
//    then the code is
// 
// 	00		0x04
// 	010		0x03
// 	011		0x05
// 	100		0x06
// 	101		0x02
// 	1100		0x07
// 	1101		0x01
// 	11100		0x08
// 	11101		0x09
// 	11110		0x00
// 	111110		0x0a
// 	1111110		0x0b
// 	1111111		0xff
//  */
// ushort * CLASS make_decoder_ref (const uchar **source)
// {
//   int max, len, h, i, j;
//   const uchar *count;
//   ushort *huff;
// 
//   count = (*source += 16) - 17;
//   for (max=16; max && !count[max]; max--);
//   huff = (ushort *) calloc (1 + (1 << max), sizeof *huff);
//   merror (huff, "make_decoder()");
//   huff[0] = max;
//   for (h=len=1; len <= max; len++)
//     for (i=0; i < count[len]; i++, ++*source)
//       for (j=0; j < 1 << (max-len); j++)
// 	if (h <= 1 << max)
// 	  huff[h++] = len << 8 | **source;
//   return huff;
// }
// 
// ushort * CLASS make_decoder (const uchar *source)
// {
//   return make_decoder_ref (&source);
// }
// 
// void CLASS crw_init_tables (unsigned table, ushort *huff[2])
// {
//   static const uchar first_tree[3][29] = {
//     { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,
//       0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff  },
//     { 0,2,2,3,1,1,1,1,2,0,0,0,0,0,0,0,
//       0x03,0x02,0x04,0x01,0x05,0x00,0x06,0x07,0x09,0x08,0x0a,0x0b,0xff  },
//     { 0,0,6,3,1,1,2,0,0,0,0,0,0,0,0,0,
//       0x06,0x05,0x07,0x04,0x08,0x03,0x09,0x02,0x00,0x0a,0x01,0x0b,0xff  },
//   };
//   static const uchar second_tree[3][180] = {
//     { 0,2,2,2,1,4,2,1,2,5,1,1,0,0,0,139,
//       0x03,0x04,0x02,0x05,0x01,0x06,0x07,0x08,
//       0x12,0x13,0x11,0x14,0x09,0x15,0x22,0x00,0x21,0x16,0x0a,0xf0,
//       0x23,0x17,0x24,0x31,0x32,0x18,0x19,0x33,0x25,0x41,0x34,0x42,
//       0x35,0x51,0x36,0x37,0x38,0x29,0x79,0x26,0x1a,0x39,0x56,0x57,
//       0x28,0x27,0x52,0x55,0x58,0x43,0x76,0x59,0x77,0x54,0x61,0xf9,
//       0x71,0x78,0x75,0x96,0x97,0x49,0xb7,0x53,0xd7,0x74,0xb6,0x98,
//       0x47,0x48,0x95,0x69,0x99,0x91,0xfa,0xb8,0x68,0xb5,0xb9,0xd6,
//       0xf7,0xd8,0x67,0x46,0x45,0x94,0x89,0xf8,0x81,0xd5,0xf6,0xb4,
//       0x88,0xb1,0x2a,0x44,0x72,0xd9,0x87,0x66,0xd4,0xf5,0x3a,0xa7,
//       0x73,0xa9,0xa8,0x86,0x62,0xc7,0x65,0xc8,0xc9,0xa1,0xf4,0xd1,
//       0xe9,0x5a,0x92,0x85,0xa6,0xe7,0x93,0xe8,0xc1,0xc6,0x7a,0x64,
//       0xe1,0x4a,0x6a,0xe6,0xb3,0xf1,0xd3,0xa5,0x8a,0xb2,0x9a,0xba,
//       0x84,0xa4,0x63,0xe5,0xc5,0xf3,0xd2,0xc4,0x82,0xaa,0xda,0xe4,
//       0xf2,0xca,0x83,0xa3,0xa2,0xc3,0xea,0xc2,0xe2,0xe3,0xff,0xff  },
//     { 0,2,2,1,4,1,4,1,3,3,1,0,0,0,0,140,
//       0x02,0x03,0x01,0x04,0x05,0x12,0x11,0x06,
//       0x13,0x07,0x08,0x14,0x22,0x09,0x21,0x00,0x23,0x15,0x31,0x32,
//       0x0a,0x16,0xf0,0x24,0x33,0x41,0x42,0x19,0x17,0x25,0x18,0x51,
//       0x34,0x43,0x52,0x29,0x35,0x61,0x39,0x71,0x62,0x36,0x53,0x26,
//       0x38,0x1a,0x37,0x81,0x27,0x91,0x79,0x55,0x45,0x28,0x72,0x59,
//       0xa1,0xb1,0x44,0x69,0x54,0x58,0xd1,0xfa,0x57,0xe1,0xf1,0xb9,
//       0x49,0x47,0x63,0x6a,0xf9,0x56,0x46,0xa8,0x2a,0x4a,0x78,0x99,
//       0x3a,0x75,0x74,0x86,0x65,0xc1,0x76,0xb6,0x96,0xd6,0x89,0x85,
//       0xc9,0xf5,0x95,0xb4,0xc7,0xf7,0x8a,0x97,0xb8,0x73,0xb7,0xd8,
//       0xd9,0x87,0xa7,0x7a,0x48,0x82,0x84,0xea,0xf4,0xa6,0xc5,0x5a,
//       0x94,0xa4,0xc6,0x92,0xc3,0x68,0xb5,0xc8,0xe4,0xe5,0xe6,0xe9,
//       0xa2,0xa3,0xe3,0xc2,0x66,0x67,0x93,0xaa,0xd4,0xd5,0xe7,0xf8,
//       0x88,0x9a,0xd7,0x77,0xc4,0x64,0xe2,0x98,0xa5,0xca,0xda,0xe8,
//       0xf3,0xf6,0xa9,0xb2,0xb3,0xf2,0xd2,0x83,0xba,0xd3,0xff,0xff  },
//     { 0,0,6,2,1,3,3,2,5,1,2,2,8,10,0,117,
//       0x04,0x05,0x03,0x06,0x02,0x07,0x01,0x08,
//       0x09,0x12,0x13,0x14,0x11,0x15,0x0a,0x16,0x17,0xf0,0x00,0x22,
//       0x21,0x18,0x23,0x19,0x24,0x32,0x31,0x25,0x33,0x38,0x37,0x34,
//       0x35,0x36,0x39,0x79,0x57,0x58,0x59,0x28,0x56,0x78,0x27,0x41,
//       0x29,0x77,0x26,0x42,0x76,0x99,0x1a,0x55,0x98,0x97,0xf9,0x48,
//       0x54,0x96,0x89,0x47,0xb7,0x49,0xfa,0x75,0x68,0xb6,0x67,0x69,
//       0xb9,0xb8,0xd8,0x52,0xd7,0x88,0xb5,0x74,0x51,0x46,0xd9,0xf8,
//       0x3a,0xd6,0x87,0x45,0x7a,0x95,0xd5,0xf6,0x86,0xb4,0xa9,0x94,
//       0x53,0x2a,0xa8,0x43,0xf5,0xf7,0xd4,0x66,0xa7,0x5a,0x44,0x8a,
//       0xc9,0xe8,0xc8,0xe7,0x9a,0x6a,0x73,0x4a,0x61,0xc7,0xf4,0xc6,
//       0x65,0xe9,0x72,0xe6,0x71,0x91,0x93,0xa6,0xda,0x92,0x85,0x62,
//       0xf3,0xc5,0xb2,0xa4,0x84,0xba,0x64,0xa5,0xb3,0xd2,0x81,0xe5,
//       0xd3,0xaa,0xc4,0xca,0xf2,0xb1,0xe4,0xd1,0x83,0x63,0xea,0xc3,
//       0xe2,0x82,0xf1,0xa3,0xc2,0xa1,0xc1,0xe3,0xa2,0xe1,0xff,0xff  }
//   };
//   if (table > 2) table = 2;
//   huff[0] = make_decoder ( first_tree[table]);
//   huff[1] = make_decoder (second_tree[table]);
// }
// 
// /*
//    Return 0 if the image starts with compressed data,
//    1 if it starts with uncompressed low-order bits.
// 
//    In Canon compressed data, 0xff is always followed by 0x00.
//  */
// int CLASS canon_has_lowbits()
// {
//   uchar test[0x4000];
//   int ret=1, i;
// 
//   fseek (ifp, 0, SEEK_SET);
//   fread (test, 1, sizeof test, ifp);
//   for (i=540; i < sizeof test - 1; i++)
//     if (test[i] == 0xff) {
//       if (test[i+1]) return 1;
//       ret=0;
//     }
//   return ret;
// }
// 
// void CLASS canon_load_raw()
// {
//   ushort *pixel, *prow, *huff[2];
//   int nblocks, lowbits, i, c, row, r, save, val;
//   int block, diffbuf[64], leaf, len, diff, carry=0, pnum=0, base[2];
// 
//   crw_init_tables (tiff_compress, huff);
//   lowbits = canon_has_lowbits();
//   if (!lowbits) maximum = 0x3ff;
//   fseek (ifp, 540 + lowbits*raw_height*raw_width/4, SEEK_SET);
//   zero_after_ff = 1;
//   getbits(-1);
//   for (row=0; row < raw_height; row+=8) {
//     pixel = raw_image + row*raw_width;
//     nblocks = MIN (8, raw_height-row) * raw_width >> 6;
//     for (block=0; block < nblocks; block++) {
//       memset (diffbuf, 0, sizeof diffbuf);
//       for (i=0; i < 64; i++ ) {
// 	leaf = gethuff(huff[i > 0]);
// 	if (leaf == 0 && i) break;
// 	if (leaf == 0xff) continue;
// 	i  += leaf >> 4;
// 	len = leaf & 15;
// 	if (len == 0) continue;
// 	diff = getbits(len);
// 	if ((diff & (1 << (len-1))) == 0)
// 	  diff -= (1 << len) - 1;
// 	if (i < 64) diffbuf[i] = diff;
//       }
//       diffbuf[0] += carry;
//       carry = diffbuf[0];
//       for (i=0; i < 64; i++ ) {
// 	if (pnum++ % raw_width == 0)
// 	  base[0] = base[1] = 512;
// 	if ((pixel[(block << 6) + i] = base[i & 1] += diffbuf[i]) >> 10)
// 	  derror();
//       }
//     }
//     if (lowbits) {
//       save = ftell(ifp);
//       fseek (ifp, 26 + row*raw_width/4, SEEK_SET);
//       for (prow=pixel, i=0; i < raw_width*2; i++) {
// 	c = fgetc(ifp);
// 	for (r=0; r < 8; r+=2, prow++) {
// 	  val = (*prow << 2) + ((c >> r) & 3);
// 	  if (raw_width == 2672 && val < 512) val += 2;
// 	  *prow = val;
// 	}
//       }
//       fseek (ifp, save, SEEK_SET);
//     }
//   }
//   FORC(2) free (huff[c]);
// }

#endregion
